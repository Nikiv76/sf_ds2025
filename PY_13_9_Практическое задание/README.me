# Проект HW-02. Исследование причин оттока клиентов из банка (рабочее название)


## Оглавление
[1. Описание проекта](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Описание-проекта)   
[2. Какой кейс решаем?](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Какой-кейс-решаем)     
[3. Краткая информация о данных](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Краткая-информация-о-данных)   
[4. Этапы работы над проектом](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Этапы-работы-над-проектом)  
[5. Результаты](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Результаты)   
[6. Выводы](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Выводы)   
[7. Свои выводы](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Свои-выводы)

### Описание проекта
Произвести анализ исходных данных. С помощью графиков обосновать свои выводы и сделать заключение
о факторах которые влияют на отток клиентов.

:arrow_up:[ к оглавлению](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Оглавление)

### Какой кейс решаем?
Нужно изучить исходные данные(признаки), на базе исходных признаков нужно рассчитать новые признаки, 
выявить взаимосвязи, визуализировать с помощью графиков.

**Условия соревнования:**

- Компьютер загадывает число от 0 до 100 и нам его нужно угадать. Под "угадать", подразумевается "написать программу, которая угадывает число".
- Алгоритм учитывает информацию о том больше ли случайное число или меньше нужного нам.
- Две программы угадывания числа даны изначально. Результат лучшей программы не удовлетворяет заданным параметрам. 
- Нужно написать третью программу, которая удовлетворяет требованиям проекта.

**Метрика качества**   
Оценивается ментером

**Что практикуем:**

- Учимся писать хороший код на Python.
- Учимся работать с IDE и GitHub
- Учимся строить графики.
- Учимся анализировать графическую информацию

:arrow_up:[ к оглавлению](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Оглавление)

### Краткая информация о данных.

Информация представлена в табличной форме соследующим списком названияя столбцов (признаков):
* RowNumber — номер строки таблицы (это лишняя информация, поэтому можете сразу от неё избавиться)
* CustomerId — идентификатор клиента
* Surname — фамилия клиента
* CreditScore — кредитный рейтинг клиента (чем он выше, тем больше клиент брал кредитов и возвращал их)
* Geography — страна клиента (банк международный)
* Gender — пол клиента
* Age — возраст клиента
* Tenure — сколько лет клиент пользуется услугами банка
* Balance — баланс на счетах клиента в банке
* NumOfProducts — количество услуг банка, которые приобрёл клиент
* HasCrCard — есть ли у клиента кредитная карта (1 — да, 0 — нет)
* IsActiveMember — есть ли у клиента статус активного клиента банка (1 — да, 0 — нет)
* EstimatedSalary — предполагаемая заработная плата клиента
* Exited — статус лояльности (1 — ушедший клиент, 0 — лояльный клиент)ю

Форма таблицы:
строк - 10000
столбцов - 22

Размер документа составляет 1,1 МБ



### Этапы работы над проектом
- Изучение исхожных данных. 
- Разработка алгоритма для метода угадывания числа меньше чем за 20 попыток.
- Реализация алгоритма в коде. 


### Результаты:
- Первая программа угадывает загаданное число в среднем за 97-98 попыток.
- Вторая программа угадывает загаданное число в среднем за 32-33 попытки.
- Третья программа (моя) уже не угадывает, а вычисляет загаданное число в среднем за 5 попыток.

:arrow_up:[ к оглавлению](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Оглавление)


## Выводы:
Первая программа работает крайне не эффективно. В программе не используется допустимая к использованию информация. Код короткий и простой.

Вторая программа учитывает информацию о том, больше предложеное число загаданного или меньше. Исходя из этого производится корректировка. Эффективность второго метода в три раза лучше первого метода. Код достаточно простой, показанная эффективность не удовлетворяет условиям проекта.

Третий метод основан на расчете. Каждое число, которое оказалось ошибочным становится границей нового более "узкого" диапазона поиска. Эффективность третьего метода в 6 раз лучше второго, т.е. высокая, возможно что максимальная. Код более длинный и более сложный. Цель достигнута - заявленные условия проекты выполнены.

## Свои выводы:
Нет полной уверенности в оптимальности третьего кода.
Возможно, что данный алгоритм можно было бы реализовать в более коротком и лаконичном коде.

:arrow_up:[ к оглавлению](https://github.com/Nikiv76/sf_ds2025/blob/main/project_HW-01/README.md#Оглавление)